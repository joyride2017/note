<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/note/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/note/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/note/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/note/favicon.ico?v=5.1.2" />






<meta name="description" content="$$\beta$$ PythonInteraction with OS and JupyterOS here refers to the Windows operating system. Jupyter refers to Jupyter Notebook, a web-based application on server-client structure allowing users to">
<meta property="og:type" content="article">
<meta property="og:title" content="Python Basics">
<meta property="og:url" content="https://joyride2017.github.io/note/2017/09/08/python-basics/index.html">
<meta property="og:site_name" content="Local Playground">
<meta property="og:description" content="$$\beta$$ PythonInteraction with OS and JupyterOS here refers to the Windows operating system. Jupyter refers to Jupyter Notebook, a web-based application on server-client structure allowing users to">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2017-09-11T23:24:42.277Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python Basics">
<meta name="twitter:description" content="$$\beta$$ PythonInteraction with OS and JupyterOS here refers to the Windows operating system. Jupyter refers to Jupyter Notebook, a web-based application on server-client structure allowing users to">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/note/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://joyride2017.github.io/note/2017/09/08/python-basics/"/>





  <title>Python Basics | Local Playground</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/note/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Local Playground</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/note/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://joyride2017.github.io/note/note/2017/09/08/python-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="n0body">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/note/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Local Playground">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python Basics</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-08T16:13:22-05:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span>$$\beta$$</span><!-- Has MathJax -->
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="Interaction-with-OS-and-Jupyter"><a href="#Interaction-with-OS-and-Jupyter" class="headerlink" title="Interaction with OS and Jupyter"></a>Interaction with OS and Jupyter</h2><p>OS here refers to the Windows operating system. Jupyter refers to Jupyter Notebook, a web-based application on server-client structure allowing users to create and manipulate .pynb file and execute it through an internet browser.</p>
<h4 id="Find-and-change-current-directory-general"><a href="#Find-and-change-current-directory-general" class="headerlink" title="Find and change current directory [general]"></a>Find and change current directory [general]</h4><p>To get the full path to the directory a Python file is contained in, write this in that file:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">cwd = os.getcwd()</div></pre></td></tr></table></figure></p>
<p>Documentation references for the modules, constants and functions used above:</p>
<ul>
<li>The <code>os</code> and <code>os.path</code> modules.</li>
<li><code>os.getcwd()</code> (returns “a string representing the current working directory”)</li>
<li><code>os.chdir(&quot;C:/path/to/location&quot;)</code> (“change the current working directory to path”)</li>
</ul>
<p><strong>Use a context manager to change the working directory</strong> Note that changing the current working directory in a subprocess (such as <code>os.chdir(path)</code>) does not change the current working directory in the parent process. This is true of the Python interpreter as well. You cannot use os.chdir() to change the CWD of the calling process. Instead use a context manager and with statement for this task:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">cd</span>:</span></div><div class="line">    <span class="string">"""Context manager for changing the current working directory"""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, newPath)</span>:</span></div><div class="line">        self.newPath = os.path.expanduser(newPath)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        self.savedPath = os.getcwd()</div><div class="line">        os.chdir(self.newPath)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, etype, value, traceback)</span>:</span></div><div class="line">        os.chdir(self.savedPath)</div></pre></td></tr></table></figure></p>
<p>Example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess <span class="comment"># just to call an arbitrary command e.g. 'ls'</span></div><div class="line"></div><div class="line"><span class="comment"># enter the directory like this:</span></div><div class="line"><span class="keyword">with</span> cd(<span class="string">"~/Library"</span>):</div><div class="line">   <span class="comment"># we are in ~/Library</span></div><div class="line">   subprocess.call(<span class="string">"ls"</span>)</div><div class="line"></div><div class="line"><span class="comment"># outside the context manager we are back wherever we started.</span></div></pre></td></tr></table></figure></p>
<h4 id="Clear-all-variables-in-variable-explorer-Spyder"><a href="#Clear-all-variables-in-variable-explorer-Spyder" class="headerlink" title="Clear all variables in variable explorer [Spyder]"></a>Clear all variables in variable explorer [Spyder]</h4><p>Simply type <code>%reset</code>. For removing a particular variable <code>bar</code>, use <code>del bar</code>.</p>
<h4 id="Tab-completion-and-introspection-Jupyter"><a href="#Tab-completion-and-introspection-Jupyter" class="headerlink" title="Tab completion and introspection [Jupyter]"></a>Tab completion and introspection [Jupyter]</h4><p>Python shell is tab completion, a feature common to most interactive data analysis  environments. While entering expressions in the shell, pressing <code>&lt;Tab&gt;</code> will search the namespace for any variables (objects, functions, etc.) matching the characters you have typed so far.</p>
<p>Using a question mark (?) before or after a variable will display some general information about the object. This is referred to as <code>object introspection</code>.</p>
<p>A number of characters combined with the wildcard <code>(*)</code> will show all names matching the wildcard expression. For example, we could get a list of all functions in the top level NumPy namespace containing <code>load</code>: <code>$ np.*load*?</code></p>
<h4 id="Execute-code-from-the-clipboard-Jupyter"><a href="#Execute-code-from-the-clipboard-Jupyter" class="headerlink" title="Execute code from the clipboard [Jupyter]"></a>Execute code from the clipboard [Jupyter]</h4><p><code>%cpaste</code> takes whatever text is in the clipboard and executes it as a single block in the shell.</p>
<h4 id="Interacting-with-the-operating-system-Jupyter"><a href="#Interacting-with-the-operating-system-Jupyter" class="headerlink" title="Interacting with the operating system [Jupyter]"></a>Interacting with the operating system [Jupyter]</h4><p><code>!cmd</code> means “execute cmd in the system shell” and <code>%pwd</code> “returns the current system working directory.”</p>
<h4 id="Timing-the-runtime-of-your-code-general"><a href="#Timing-the-runtime-of-your-code-general" class="headerlink" title="Timing the runtime of your code [general]"></a>Timing the runtime of your code [general]</h4><p>Timing code by hand using the built-in time module and its functions <code>time.clock</code> and<br><code>time.time</code> is often tedious and repetitive:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Given an arbitrary statement, this method has a heuristic to run a statement multiple times to produce an average runtime.</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line">start = time.time()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iterations):</div><div class="line">    <span class="comment"># some code to run here</span></div><div class="line">elapsed_per = (time.time() - start) / iterations</div></pre></td></tr></table></figure></p>
<p>Otherwise, two magic functions can automate the process for you: <code>%time</code> and <code>%timeit</code>.</p>
<h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><p>NumPy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.</p>
<h4 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h4><p>An <code>ndarray</code>, short for n-dimensional array, object is a generic multidimentional container for homogeneous data; all of the elements must be the same type.</p>
<h5 id="Random-ndarray"><a href="#Random-ndarray" class="headerlink" title="Random ndarray"></a>Random ndarray</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="comment"># Set precision of printout</span></div><div class="line">np.set_printoptions(precision=<span class="number">4</span>, suppress=<span class="keyword">True</span>)</div><div class="line">data = randn(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">data.dtype <span class="comment"># dtype('float64')</span></div><div class="line">data.shape <span class="comment"># tuple type; (2L, 3L)</span></div></pre></td></tr></table></figure>
<h6 id="Create-ndarrays-array-zeros-empty-arange"><a href="#Create-ndarrays-array-zeros-empty-arange" class="headerlink" title="Create ndarrays: array(), zeros(), empty(), arange()"></a>Create ndarrays: array(), zeros(), empty(), arange()</h6><p>The <code>array</code> function accepts any sequence-like object (<strong>including other arrays</strong>) and produces a new NumPy array containing the passed data. A <code>list</code> is a good candidate for conversion:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data1 = [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line">arr1 = np.array(data1)</div><div class="line">arr1.dtype <span class="comment"># dtype('float64')</span></div></pre></td></tr></table></figure></p>
<p>Nested sequences, like a list of <code>equal-legth</code> lists, will be converted into a multidimentional array:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</div><div class="line">arr2 = np.array(data2)</div><div class="line">arr2</div><div class="line">arr2.ndim <span class="comment"># 2</span></div><div class="line">arr2.shape <span class="comment"># (2L, 4L)</span></div><div class="line">arr2.dtype <span class="comment"># dtype('int32'). np.array() tries to infer a good data type for the array that it creates.</span></div></pre></td></tr></table></figure></p>
<p><code>zeros</code> and <code>ones</code> create arrays of 0’s or 1’s. To create a higher dimensional array with these methods, pass a <code>tuple</code> for the shape. Note that it’s not safe to assume that np.empty will return an array of all zeros.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">np.zeros(<span class="number">10</span>) <span class="comment"># derivative: zeros_like(), ones(), ones_like()</span></div><div class="line">np.zeros((<span class="number">3</span>, <span class="number">6</span>))</div><div class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)) <span class="comment"># derivative: empty_like()</span></div></pre></td></tr></table></figure></p>
<p><code>arange</code> is an array-valued version of the built-in Python range function. It returns an ndarray instead of a list:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.arange(<span class="number">15</span>)</div></pre></td></tr></table></figure></p>
<h5 id="Data-type-conversion-astype-float64-f8-int32-i4-np-string-np-unicode"><a href="#Data-type-conversion-astype-float64-f8-int32-i4-np-string-np-unicode" class="headerlink" title="Data type conversion: astype(), float64(=f8), int32(=i4), np.string, np.unicode"></a>Data type conversion: astype(), float64(=f8), int32(=i4), np.string<em>, np.unicode</em></h5><p>A standard double-precision floating point value (what’s used under the hood in Python’s <code>float</code> object) takes up 8 bytes or 64 bits. This type is known in NumPy as <code>float64</code>.</p>
<p>To create a string dtype with length 10, use the type code <code>S10</code>(1 byte per character). For creating a unicode dtype with length 10, use <code>U10</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</div><div class="line">arr2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</div><div class="line">arr1.dtype</div><div class="line">arr2.dtype</div><div class="line"></div><div class="line">int_arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line">int_arr.dtype</div><div class="line"><span class="comment"># method 1: astype()</span></div><div class="line"><span class="comment"># Calling astype always creates a new array (a copy of the data).</span></div><div class="line">float_arr = int_arr.astype(np.float64)</div><div class="line">float_arr.dtype <span class="comment"># dtype('float64')</span></div><div class="line"><span class="comment"># method 2: parameter dtype</span></div><div class="line">float_arr1 = np.array(int_arr,dtype=np.float64)</div><div class="line">float_arr1.dtype</div><div class="line"><span class="comment"># method 3: read dtype of existing array</span></div><div class="line">float_arr2 = int_arr.astype(float_arr1.dtype)</div><div class="line">float_arr2 <span class="comment"># array([ 1.,  2.,  3.,  4.,  5.])</span></div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">numeric_strings = np.array([<span class="string">'1.25'</span>, <span class="string">'-9.6'</span>, <span class="string">'42'</span>], dtype=np.string_)</div><div class="line">numeric_strings <span class="comment"># array(['1.25', '-9.6', '42'], dtype='|S4')</span></div><div class="line">numeric_strings.astype(float) <span class="comment"># array([  1.25,  -9.6 ,  42.  ])</span></div><div class="line"></div><div class="line">int_array = np.arange(<span class="number">10</span>)</div><div class="line">calibers = np.array([<span class="number">.22</span>, <span class="number">.270</span>, <span class="number">.357</span>, <span class="number">.380</span>, <span class="number">.44</span>, <span class="number">.50</span>], dtype=np.float64)</div><div class="line">int_array.astype(calibers.dtype)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">empty_uint32 = np.empty(<span class="number">8</span>, dtype=<span class="string">'u4'</span>)</div><div class="line">empty_uint32 <span class="comment"># array([0, 0, 0, 0, 0, 0, 0, 0], dtype=uint32)</span></div></pre></td></tr></table></figure>
<p><strong>Operations between arrays and scalars</strong> Arrays are important because they enable you to express batch operations on data without writing any for loops. This is usually called <code>vectorization</code>. Any arithmetic operations between equal-size arrays applies the operation element-wise.</p>
<h5 id="Transposing-arrays-and-swapping-axes-transpose-dot-swapaxes"><a href="#Transposing-arrays-and-swapping-axes-transpose-dot-swapaxes" class="headerlink" title="Transposing arrays and swapping axes: transpose, dot, swapaxes"></a>Transposing arrays and swapping axes: transpose, dot, swapaxes</h5><p>To compute the inner matrix product $X^T X$ use <code>np.dot</code>.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</div><div class="line">arr</div><div class="line">arr.T</div><div class="line"></div><div class="line">arr = np.random.randn(<span class="number">6</span>, <span class="number">3</span>)</div><div class="line">arr</div><div class="line">np.dot(arr.T, arr) <span class="comment"># inner matrix product</span></div><div class="line"></div><div class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</div><div class="line">arr</div><div class="line">arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</div><div class="line"></div><div class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</div><div class="line">arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>) .shape <span class="comment"># (2L, 4L, 2L)</span></div></pre></td></tr></table></figure></p>
<h4 id="Universal-functions"><a href="#Universal-functions" class="headerlink" title="Universal functions"></a>Universal functions</h4><p>fast element-wise array functions</p>
<h5 id="Unary-universal-functions"><a href="#Unary-universal-functions" class="headerlink" title="Unary universal functions"></a>Unary universal functions</h5><p>A universal function, or ufunc, is a function that performs elementwise operations on data in ndarrays. Highlights: sqrt(), square(), ceil(), floor(), rint(), modf(), isnan(), isfinite(), isinf()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">10</span>)</div><div class="line">np.sqrt(arr)</div><div class="line">np.exp(arr)</div></pre></td></tr></table></figure></p>
<h5 id="Binary-universal-functions"><a href="#Binary-universal-functions" class="headerlink" title="Binary universal functions"></a>Binary universal functions</h5><p>Take 2 arrays (thus, binary ufuncs) and return a single array as the result:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = randn(<span class="number">8</span>)</div><div class="line">y = randn(<span class="number">8</span>)</div><div class="line">x</div><div class="line">y</div><div class="line">np.maximum(x, y) <span class="comment"># element-wise maximum</span></div><div class="line">np.subtract(x,y) <span class="comment"># the same as x-y</span></div><div class="line">x - y</div><div class="line"><span class="comment"># more:</span></div><div class="line">arr = randn(<span class="number">7</span>) * <span class="number">5</span></div><div class="line">np.modf(arr)</div></pre></td></tr></table></figure></p>
<p>More: add, subtract, multiply, divide, floor_divide, power, <strong>maximum</strong>, <strong>fmax</strong>, minimum, fmin, mod, copysign</p>
<h4 id="Indexing-and-slicing"><a href="#Indexing-and-slicing" class="headerlink" title="Indexing and slicing"></a>Indexing and slicing</h4><p>If you assign a scalar value to a slice, as in arr[5:8] = 12, the value is <code>propagated</code> (or <code>broadcasted</code> henceforth) to the entire selection. An important first distinction from lists is that array slices are <code>views</code> on the original array. This means that the data is not copied, and <strong>any modifications to the view will be reflected in the source array</strong>:</p>
<h5 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h5><p>Python (and C++) is row-major, while Fortran (Julia, R, and Matlab) is column-major.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">10</span>)</div><div class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></div><div class="line">arr</div><div class="line">arr[:] = <span class="number">100</span></div><div class="line">arr <span class="comment"># array([100, 100, 100, 100, 100, 100, 100, 100, 100, 100])</span></div><div class="line">part_arr = arr[<span class="number">5</span>:<span class="number">8</span>] <span class="comment"># part_arr remains a view of arr</span></div><div class="line">part_arr[<span class="number">2</span>] = <span class="number">2</span></div><div class="line">arr <span class="comment"># array([100, 100, 100, 100, 100, 100, 100,   2, 100, 100])</span></div><div class="line"></div><div class="line"><span class="comment"># If you need to explicitly copy the array instead of a view of it, use copy()</span></div><div class="line">copy_arr = arr[<span class="number">5</span>:<span class="number">8</span>].copy() <span class="comment"># Don't miss the parenthesis!!</span></div><div class="line">copy_arr</div><div class="line">copy_arr[<span class="number">2</span>] = <span class="number">-1</span></div><div class="line">arr <span class="comment"># remains unchanged: array([100, 100, 100, 100, 100, 100, 100,   2, 100, 100])</span></div></pre></td></tr></table></figure></p>
<p>In multidimensional arrays, if you omit later indices, the returned object will be a lower-dimensional ndarray consisting of all the data along the higher dimensions.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># create a 3x4 array</span></div><div class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</div><div class="line">arr2d[<span class="number">2</span>] <span class="comment"># array([7, 8, 9])</span></div><div class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>] <span class="comment"># 3; from the outermost brackets toward the innermost</span></div><div class="line">arr2d[<span class="number">0</span>, <span class="number">2</span>] <span class="comment"># 3</span></div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</div><div class="line">arr3d.shape <span class="comment"># (2L, 2L, 3L)</span></div><div class="line">arr3d[<span class="number">0</span>] <span class="comment"># the 1st element of the "outtermost" bracket ("lowest" dimension)</span></div><div class="line">         <span class="comment"># array([[1, 2, 3], [4, 5, 6]])</span></div></pre></td></tr></table></figure>
<h5 id="Indexing-with-slices"><a href="#Indexing-with-slices" class="headerlink" title="Indexing with slices"></a>Indexing with slices</h5><p>A slice selects a range of elements along an axis.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">arr2d = np.array(range(<span class="number">12</span>)).reshape((<span class="number">3</span>,<span class="number">4</span>))</div><div class="line">arr2d <span class="comment"># array([[ 0,  1,  2,  3],</span></div><div class="line">      <span class="comment"># [ 4,  5,  6,  7],</span></div><div class="line">      <span class="comment"># [ 8,  9, 10, 11]])</span></div><div class="line">arr2d[:<span class="number">2</span>] <span class="comment"># array([[0, 1, 2, 3],</span></div><div class="line">          <span class="comment">#        [4, 5, 6, 7]])</span></div></pre></td></tr></table></figure></p>
<p>Note that a colon by itself means to take the entire axis, so you can slice only higher dimensional axes by doing:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr2d[:, :<span class="number">1</span>] <span class="comment"># array([[0],</span></div><div class="line">             <span class="comment">#        [4],</span></div><div class="line">             <span class="comment">#        [8]])</span></div></pre></td></tr></table></figure></p>
<h5 id="Boolean-indexing"><a href="#Boolean-indexing" class="headerlink" title="Boolean indexing"></a>Boolean indexing</h5><p><strong>Make a subset of observations</strong> The boolean array must be of the same length as the axis it’s indexing. Selecting data from an array by boolean indexing always creates a copy of the data, even if the returned array is <strong>unchanged</strong>.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</div><div class="line">data = np.arange(<span class="number">28</span>).reshape((<span class="number">7</span>,<span class="number">4</span>))</div><div class="line">names <span class="comment"># array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='|S4')</span></div><div class="line">names == <span class="string">'Bob'</span> <span class="comment"># array([ True, False, False,  True, False, False, False], dtype=bool)</span></div><div class="line">data</div><div class="line">data[names == <span class="string">'Bob'</span>] <span class="comment"># row 0 and row 4 remain</span></div><div class="line">data[names == <span class="string">'Bob'</span>, <span class="number">2</span>:] <span class="comment"># from column 2 to the last (included)</span></div><div class="line">data[names == <span class="string">'Bob'</span>, <span class="number">3</span>]</div><div class="line"></div><div class="line">names != <span class="string">'Bob'</span></div><div class="line">data[-(names == <span class="string">'Bob'</span>)]</div><div class="line"></div><div class="line">mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)</div><div class="line">mask <span class="comment"># array([ True, False,  True,  True,  True, False, False], dtype=bool)</span></div><div class="line">data[mask]</div></pre></td></tr></table></figure></p>
<p>The Python keywords <code>and</code> and <code>or</code> do not work with boolean arrays, because the boolean operators <code>and</code> and <code>or</code> in Python are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (continued)</span></div><div class="line">data[data &lt; <span class="number">3</span> ] = <span class="number">0</span> <span class="comment"># OK.</span></div><div class="line">data</div><div class="line">data[data &gt;=<span class="number">24</span> <span class="keyword">and</span> data == <span class="number">0</span>] = <span class="number">10</span> <span class="comment"># It doesn't work.</span></div><div class="line"></div><div class="line">data[names != <span class="string">'Joe'</span>] = <span class="number">7</span></div><div class="line">data</div></pre></td></tr></table></figure></p>
<h5 id="Fancy-indexing-ix"><a href="#Fancy-indexing-ix" class="headerlink" title="Fancy indexing: ix_()"></a>Fancy indexing: ix_()</h5><p>Fancy indexing is a term adopted by NumPy to describe indexing using integer <code>arrays</code>. To select out a subset of the <code>rows</code> in a particular order, you can simply pass a list or ndarray of integers specifying the desired order<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</div><div class="line"><span class="comment"># [Trick] fill up row data with loop.</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">    arr[i] = i</div><div class="line">arr</div><div class="line">arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]]</div><div class="line"><span class="comment"># Using negative indices select rows from the end</span></div><div class="line">arr[[<span class="number">-3</span>, <span class="number">-5</span>, <span class="number">-7</span>]]</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</div><div class="line">arr</div><div class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]] <span class="comment"># returns four elements: array([ 4, 23, 29, 10])</span></div><div class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]] <span class="comment"># the rectangular region formed by the four elements</span></div><div class="line"><span class="comment"># Similarly, the np.ix_ function converts two 1D integer arrays to an indexer that selects the square region</span></div><div class="line">arr[np.ix_([<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])]</div></pre></td></tr></table></figure>
<h5 id="Application-of-meshgrid-method"><a href="#Application-of-meshgrid-method" class="headerlink" title="Application of meshgrid method"></a>Application of meshgrid method</h5><p>The np.meshgrid function takes two 1D arrays and produces two 2D matrices corresponding to all pairs of (x, y) in the two arrays.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">points = np.arange(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.01</span>) <span class="comment"># 1000 equally spaced points</span></div><div class="line">xs, ys = np.meshgrid(points, points)</div><div class="line">xs <span class="comment"># in increasing order from left to right</span></div><div class="line">ys <span class="comment"># in increasing order from top to bottom</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> imshow, title</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</div><div class="line">z</div><div class="line">plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</div><div class="line">plt.title(<span class="string">"Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h5 id="Conditional-logic-on-array-operations-zip-all-where"><a href="#Conditional-logic-on-array-operations-zip-all-where" class="headerlink" title="Conditional logic on array operations: zip, all, where"></a>Conditional logic on array operations: zip, all, where</h5><p>Expressing conditional logic as array operations<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</div><div class="line">yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</div><div class="line">cond = np.array([<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">False</span>])</div><div class="line"></div><div class="line">result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y)</div><div class="line">          <span class="keyword">for</span> x, y, c <span class="keyword">in</span> zip(xarr, yarr, cond)]</div><div class="line">result</div></pre></td></tr></table></figure></p>
<p>The numpy.where function is a vectorized version of the ternary expression <code>x if condition else y</code>. A typical use of where in data analysis is to produce a new array of values based on another array. Suppose you had a matrix of randomly generated data and you wanted to replace all positive values with 2 and all negative values with -2.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (continued)</span></div><div class="line">result = np.where(cond, xarr, yarr)</div><div class="line">result</div></pre></td></tr></table></figure></p>
<p>Application of partial replacement:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">4</span>, <span class="number">4</span>)</div><div class="line">arr</div><div class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, <span class="number">-2</span>)</div><div class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr) <span class="comment"># set only positive values to 2</span></div></pre></td></tr></table></figure></p>
<p>Consider I have two boolean arrays, cond1 and cond2, and wish to assign a different value for each of the 4 (2x2=4) possible pairs of boolean values.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Method 1. traditional version</span></div><div class="line">result = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    <span class="keyword">if</span> cond1[i] <span class="keyword">and</span> cond2[i]:</div><div class="line">        result.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">elif</span> cond1[i]:</div><div class="line">        result.append(<span class="number">1</span>)</div><div class="line">    <span class="keyword">elif</span> cond2[i]:</div><div class="line">        result.append(<span class="number">2</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        result.append(<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="comment"># Method 2. improved version</span></div><div class="line">np.where(cond1 &amp; cond2, <span class="number">0</span>,</div><div class="line">         np.where(cond1, <span class="number">1</span>,</div><div class="line">                  np.where(cond2, <span class="number">2</span>, <span class="number">3</span>)))</div></pre></td></tr></table></figure></p>
<p>Boolean values are treated as 0 or 1 in calculations. Since python supports <code>chaining relational</code> operators (i.e. you can use 0 &lt; var &lt; 100 instead of 0 &lt; var and var &lt; 100) and processes binary operations (i.e. addition, subtraction, bitwise operations, etc.) before relational (comparison) operators due to operator precedence, so the follow conditions all give <strong>False</strong>: <a href="https://stackoverflow.com/questions/41390988/python-bitwise-operators-operator" target="_blank" rel="external">given</a> var=86:</p>
<ol>
<li>var &lt; 90 &amp; var &gt;= 80 is equivalent to (var &lt; 90 &amp; var) and (90 &amp; var &gt;= 80)</li>
<li>var &lt; 90 &amp; (var&gt;=80) is equivalent to var &lt; 90 &amp; True for which look at the 4th case.</li>
<li>(var<90) &="" var="">=80 is also similar to the 4th case (this resolves to True &amp; var &gt;= 80 which will then resolve to 0 &gt;= 80).</90)></li>
<li>var &lt; 90 &amp; True is equivalent to var &lt; (90 &amp; True). The implementation of the <code>&amp;</code> operator is designed to <strong>return 0 if either one of the operands is not an integer</strong> (which is another one of the biggest pitfalls of dynamic typing), which is why all such similar statements resolve to var &lt; 0 which is false.<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (continued)</span></div><div class="line"><span class="comment"># Method 3. Alternative method</span></div><div class="line">result = <span class="number">1</span> * cond1 + <span class="number">2</span> * cond2 + <span class="number">3</span> * - (cond1 | cond2)</div><div class="line"><span class="comment"># Example:</span></div><div class="line">ray =  <span class="number">10</span></div><div class="line">result = <span class="number">1</span>*(ray&gt;<span class="number">7</span>) + <span class="number">2</span>*(ray&lt;<span class="number">3</span>) + <span class="number">3</span> * -( ray&gt;<span class="number">7</span> | ray&lt;<span class="number">3</span> ) <span class="comment"># we use bitwise operator OR.</span></div><div class="line">result</div></pre></td></tr></table></figure>
</li>
</ol>
<p>more: <a href="https://www.programiz.com/python-programming/operators#bitwise_operators" target="_blank" rel="external">Bitwise operators</a>;<br><a href="http://blog.csdn.net/carolzhang8406/article/details/6091649" target="_blank" rel="external">Operator Precednece</a></p>
<h5 id="Application-of-boolean-array-counting-events"><a href="#Application-of-boolean-array-counting-events" class="headerlink" title="Application of boolean array: counting events"></a>Application of boolean array: counting events</h5><p>Boolean values are coerced to 1 (True) and 0 (False) in the above methods. Thus, sum<br>is often used as a means of <code>counting</code> True values in a boolean array:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">100</span>)</div><div class="line">(arr &gt; <span class="number">0</span>).sum() <span class="comment"># Number of positive values</span></div></pre></td></tr></table></figure></p>
<p><code>any</code> tests whether one or more values in an array is True, while <code>all</code> checks if every value is True:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bools = np.array([<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>])</div><div class="line">bools.any()</div><div class="line">bools.all()</div></pre></td></tr></table></figure></p>
<h5 id="Set-logic-unique"><a href="#Set-logic-unique" class="headerlink" title="Set logic: unique()"></a>Set logic: unique()</h5><p>NumPy has some basic set operations for <code>one-dimensional</code> ndarrays. Probably the most commonly used one is np.unique, which returns the sorted unique values in an array:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</div><div class="line">np.unique(names) <span class="comment"># array(['Bob', 'Joe', 'Will'], dtype='|S4')</span></div><div class="line">ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</div><div class="line"><span class="comment"># Method 1.</span></div><div class="line">np.unique(ints) <span class="comment"># array([1, 2, 3, 4])</span></div><div class="line"><span class="comment"># Method 2. a pure Python alternavie</span></div><div class="line">sorted(set(names)) <span class="comment"># ['Bob', 'Joe', 'Will']</span></div></pre></td></tr></table></figure></p>
<p>To test membership of the values in one array in another, returning a boolean array, use <code>in1d</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</div><div class="line">np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]) <span class="comment"># array([ True, False, False,  True,  True, False,  True], dtype=bool)</span></div></pre></td></tr></table></figure></p>
<p>more: intersect1d, union1d, setdiff1d, setxor1d<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<h4 id="Math-and-stat-methods"><a href="#Math-and-stat-methods" class="headerlink" title="Math and stat methods"></a>Math and stat methods</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>) <span class="comment"># normally-distributed data</span></div><div class="line"></div><div class="line">arr.mean() <span class="comment"># itw own method (method 1)</span></div><div class="line">np.mean(arr) <span class="comment"># function from NumPy (method 2)</span></div><div class="line"></div><div class="line">arr.sum()</div><div class="line">arr.mean(axis=<span class="number">1</span>) <span class="comment"># Over axis 1: take average over axis=1 (columns) for each row; axis=1 collapses in the end)</span></div><div class="line">arr.sum(<span class="number">0</span>) <span class="comment"># Over axis 0: sum over rows for each column; axis=0 collapses</span></div></pre></td></tr></table></figure>
<p>Other methods like <code>cumsum</code> and <code>cumprod</code> do not aggregate, instead producing an array<br>of the intermediate results:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line">arr.cumsum(<span class="number">0</span>) <span class="comment"># Over axis 0: sum over rows for each column</span></div><div class="line">arr.cumprod(<span class="number">1</span>) <span class="comment"># Over axis 1: product across columns for each row; values related to horizontal neighboring elements</span></div></pre></td></tr></table></figure></p>
<p>More: min, max, argmin, argmax</p>
<h5 id="application-of-sorting-quantiles"><a href="#application-of-sorting-quantiles" class="headerlink" title="application of sorting: quantiles"></a>application of sorting: quantiles</h5><p>The top level method <code>np.sort</code> returns a sorted copy of an array instead of modifying<br>the array in place.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line">l = range(<span class="number">1</span>,<span class="number">10</span>)</div><div class="line">ray = random.sample(l,<span class="number">8</span>)</div><div class="line">ray <span class="comment"># [4, 7, 2, 6, 5, 1, 8, 3]</span></div><div class="line"></div><div class="line">arr = np.array(ray)</div><div class="line">arr</div><div class="line"><span class="comment"># Method 1</span></div><div class="line">np.sort(arr) <span class="comment"># returns array([1, 2, 3, 4, 5, 6, 7, 8]), but arr doesn't change.</span></div><div class="line">arr</div><div class="line"><span class="comment"># Method 2</span></div><div class="line">arr.sort() <span class="comment"># use its own method. arr changes.</span></div><div class="line">arr</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line">arr = randn(<span class="number">8</span>)</div><div class="line">arr</div><div class="line">arr.sort()</div><div class="line">arr</div><div class="line"><span class="comment"># two dimensional ndarray</span></div><div class="line">arr = randn(<span class="number">5</span>, <span class="number">3</span>)</div><div class="line">arr</div><div class="line">arr.sort(<span class="number">1</span>) <span class="comment"># Over axis 1 (sorting within each row vector)</span></div><div class="line">arr</div></pre></td></tr></table></figure>
<p>Task: Compute the quantiles of an array.<br>Hint: use the <code>sort</code> method to have it sorted in-place.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">large_arr = randn(<span class="number">10</span>)</div><div class="line">large_arr</div><div class="line">large_arr.sort()</div><div class="line">large_arr</div><div class="line">large_arr[int(<span class="number">0.05</span> * len(large_arr))] <span class="comment"># 5% quantile</span></div></pre></td></tr></table></figure></p>
<h4 id="File-input-and-output"><a href="#File-input-and-output" class="headerlink" title="File input and output"></a>File input and output</h4><h5 id="np-save-np-load-np-savez"><a href="#np-save-np-load-np-savez" class="headerlink" title="np.save, np.load, np.savez"></a>np.save, np.load, np.savez</h5><p><code>np.save</code> and <code>np.load</code> are the two workhorse functions for efficiently saving and loading<br>array data on disk. Arrays are saved by default in an uncompressed raw binary format<br>with file extension <code>.npy</code>.</p>
<p>When loading an <code>.npz</code> file, you get back a <code>dict-like</code> object which loads the individual arrays lazily<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">10</span>)</div><div class="line"><span class="comment"># Method 1. generic method</span></div><div class="line">np.save(<span class="string">'some_array'</span>, arr)</div><div class="line">np.load(<span class="string">'some_array.npy'</span>)</div><div class="line"><span class="comment"># Method 2. save in a zip archive. When loading an .npz file, you get back a dict-like object:</span></div><div class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr)</div><div class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</div><div class="line">arch[<span class="string">'b'</span>]</div></pre></td></tr></table></figure></p>
<h5 id="np-loadtxt"><a href="#np-loadtxt" class="headerlink" title="np.loadtxt"></a>np.loadtxt</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = np.loadtxt(<span class="string">'array_ex.txt'</span>, delimiter=<span class="string">','</span>)</div><div class="line">arr</div></pre></td></tr></table></figure>
<h4 id="Linear-algebra"><a href="#Linear-algebra" class="headerlink" title="Linear algebra"></a>Linear algebra</h4><p>There is a function <code>dot</code>, both an array method, and a function in the numpy namespace, for matrix multiplication:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">x = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</div><div class="line">y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [<span class="number">-1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</div><div class="line">x</div><div class="line">y</div><div class="line"><span class="comment"># Method 1.</span></div><div class="line">x.dot(y)</div><div class="line"><span class="comment"># Method 2.</span></div><div class="line">np.dot(x,y)</div><div class="line"></div><div class="line">np.dot(x, np.ones(<span class="number">3</span>))</div><div class="line">np.random.seed(<span class="number">12345</span>)</div></pre></td></tr></table></figure></p>
<p><code>numpy.linalg</code> has a standard set of matrix decompositions and things like inverse anddeterminant.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</div><div class="line">X = randn(<span class="number">5</span>, <span class="number">5</span>)</div><div class="line">mat = X.T.dot(X)</div><div class="line">inv(mat)</div><div class="line">mat.dot(inv(mat))</div><div class="line"><span class="comment"># decomposition</span></div><div class="line">q, r = qr(mat)</div><div class="line">r</div></pre></td></tr></table></figure></p>
<p>more: diag, dot, trace, det, eig, inv, pinv, qr, svd, <strong>solve</strong>, lstsq</p>
<h4 id="Random-number-generation"><a href="#Random-number-generation" class="headerlink" title="Random number generation"></a>Random number generation</h4><p>The <code>numpy.random</code> module supplements the built-in Python random with functions for<br>efficiently generating whole arrays of sample values from many kinds of probability distribution.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</div><div class="line">samples</div></pre></td></tr></table></figure></p>
<h5 id="faster-randomization"><a href="#faster-randomization" class="headerlink" title="faster randomization"></a>faster randomization</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> normalvariate</div><div class="line">N = <span class="number">1000000</span></div><div class="line">%timeit samples = [normalvariate(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(N)]</div><div class="line">%timeit np.random.normal(size=N)</div></pre></td></tr></table></figure>
<p>more: seed, permutation, shuffle, rand, randint, randn, binomial, normal, beta, chisquare, gamma, uniform</p>
<p><code>xrange</code> is a sequence object that evaluates lazily. <code>range</code> creates a list, so if you do range(1, 10000000) it creates a <code>list</code> in memory with 10000000 elements. xrange is a generator, so it is a <code>sequence object</code> is a that evaluates lazily.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Example: Random Walks</span></div><div class="line"><span class="comment"># Method 1. generic way</span></div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">position = <span class="number">0</span> <span class="comment"># location on the y-axis overtime</span></div><div class="line">walk = [position]</div><div class="line">steps = <span class="number">1000</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(steps<span class="number">-1</span>):</div><div class="line">  step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></div><div class="line">  position += step</div><div class="line">  walk.append(position)</div><div class="line">plt.plot(range(steps),walk)</div><div class="line">plt.show()</div></pre></td></tr></table></figure></p>
<p>Alternatively, use the np.random module to draw 1,000 coin flips at once, set these to 1 and -1, and compute the cumulative sum.</p>
<p>Task: <strong>First crossing time</strong>, the step at which a random walk reaches a particular value.<br>How long did it take the random walk to get at least 10 steps away from the origin 0 in either direction<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Method 2. use np.random module</span></div><div class="line">np.random.seed(<span class="number">12345</span>)</div><div class="line">nsteps = <span class="number">1000</span></div><div class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps) <span class="comment"># draw an integer N from [a,b), b is not included</span></div><div class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</div><div class="line">walk = steps.cumsum()</div><div class="line">plt.plot(range(nsteps),walk)</div><div class="line">plt.show()</div><div class="line">walk.min()</div><div class="line">walk.max()</div><div class="line">(np.abs(walk) &gt;= <span class="number">10</span>).argmax() <span class="comment"># 37</span></div></pre></td></tr></table></figure></p>
<p>Turns out this can be computed using argmax, which returns the first index of the maximum value in the boolean array (<strong>True is the maximum value</strong>). Note that using argmax here is not always efficient because it always makes a full scan of the array. In this special case once a True is observed we know it to be the maximum value.</p>
<h5 id="first-crossing-times"><a href="#first-crossing-times" class="headerlink" title="first crossing times"></a>first crossing times</h5><p><strong>Simulating many random walks at once</strong><br>Task: Compute the minimum crossing time to 30 or -30.<br>Hint: Compute the average of the first crossing time across histories<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">nwalks = <span class="number">5000</span></div><div class="line">nsteps = <span class="number">1000</span></div><div class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(nwalks, nsteps)) <span class="comment"># 0 or 1</span></div><div class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</div><div class="line">walks = steps.cumsum(<span class="number">1</span>) <span class="comment"># trick.</span></div><div class="line">walks</div><div class="line">walks.max()</div><div class="line">walks.min()</div><div class="line"><span class="comment"># Count histories that hit the level of 30</span></div><div class="line">hits30 = (np.abs(walks) &gt;= <span class="number">30</span>).any(<span class="number">1</span>)</div><div class="line">hits30</div><div class="line">hits30.shape</div><div class="line">hits30.sum()</div><div class="line"><span class="comment"># To select out the rows of walks that actually cross the absolute 30 level</span></div><div class="line">crossing_times = (np.abs(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</div><div class="line">crossing_times <span class="comment"># the first index in each history that hits the level 30 or -30</span></div><div class="line">(np.abs(walks[hits30]) &gt;= <span class="number">30</span>)</div><div class="line">crossing_times.mean()</div></pre></td></tr></table></figure></p>
<p>Experiment with other probablity distribution for the steps other than equal sized coin flips:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">steps = np.random.normal(loc=<span class="number">0</span>, scale=<span class="number">0.25</span>, size=(nwalks, nsteps))</div></pre></td></tr></table></figure></p>
<h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><p>Data preparation refers to cleaning, munging, wranggling, reshaping raw data.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">np.random.seed(<span class="number">12345</span>)</div><div class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</div><div class="line">np.set_printoptions(precision=<span class="number">4</span>)</div></pre></td></tr></table></figure>
<h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><p>A <code>Series</code> is a one-dimensional array-like object containing an array of data (of any NumPy data type) and an associated array of data labels, called its <code>index</code>. Compared with a regular NumPy array, you can use values in the index when selecting single values or a set of values.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">obj = Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>])</div><div class="line">obj</div><div class="line">obj.values</div><div class="line">obj.index</div><div class="line"></div><div class="line">obj2 = Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</div><div class="line">obj2</div><div class="line">obj2.index</div><div class="line">obj2[<span class="string">'a'</span>]</div><div class="line">obj2[<span class="string">'d'</span>] = <span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>NumPy array operations, such as filtering with a boolean array, scalar multiplication,<br>or applying math functions, will preserve the index-value link:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">obj2[[<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]]</div><div class="line">obj2</div><div class="line">obj2[obj2 &gt; <span class="number">0</span>]</div><div class="line">obj2 * <span class="number">2</span></div><div class="line">np.exp(obj2)</div></pre></td></tr></table></figure></p>
<p>Another way to think about a Series is as a fixed-length, <code>ordered dict</code>, as it is a mapping<br>of index values to data values.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'b'</span> <span class="keyword">in</span> obj2</div><div class="line"><span class="string">'e'</span> <span class="keyword">in</span> obj2</div></pre></td></tr></table></figure></p>
<p><strong>When to use series.</strong> If you have data contained in a Python dict, you can a Series from it by passing the dict:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</div><div class="line">obj3 = Series(sdata)</div><div class="line">obj3</div><div class="line">states = [<span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Oregon'</span>, <span class="string">'Texas'</span>]</div><div class="line">obj4 = Series(sdata, index=states)</div><div class="line">obj4</div></pre></td></tr></table></figure></p>
<p>When only passing a dict, the index in the resulting Series will have the dict’s keys in sorted order. In this case, 3 values found in <em>sdata</em> were placed in the appropriate locations, but since no value for ‘California’ was found, it appears as <code>NaN</code> (not a number) which is considered in pandas to mark missing or NA values.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (continued)</span></div><div class="line">pd.isnull(obj4)</div><div class="line">pd.notnull(obj4) <span class="comment"># reverse of the answer in last line</span></div><div class="line">obj4.isnull() <span class="comment"># Series has its own isnull method</span></div><div class="line">obj3</div><div class="line">obj4 <span class="comment"># Utah is screened out from obj4 because `Utah` is considered when obj4 is created.</span></div><div class="line">(obj3 + obj4).index <span class="comment"># Index([u'California', u'Ohio', u'Oregon', u'Texas', u'Utah'], dtype='object')</span></div><div class="line">(obj3 + obj4).values <span class="comment"># array([     nan,   70000.,   32000.,  142000.,      nan]) # Two NaN show.</span></div><div class="line"></div><div class="line">obj4.name = <span class="string">'population'</span></div><div class="line">obj4.index.name = <span class="string">'state'</span></div><div class="line">obj4</div></pre></td></tr></table></figure></p>
<p>A Series’s index can be altered in place by assignment:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj.index = [<span class="string">'Bob'</span>, <span class="string">'Steve'</span>, <span class="string">'Jeff'</span>, <span class="string">'Ryan'</span>]</div><div class="line">obj</div></pre></td></tr></table></figure></p>
<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>The DataFrame has both a row and column index; it can be thought of as a dict of Series,  each of which can be a different value type (numeric, string, boolean, etc.). The resulting DataFrame will have its index assigned automatically as with Series, and the columns are placed in sorted order.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>], <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]&#125;</div><div class="line">frame = DataFrame(data)</div><div class="line">frame</div><div class="line"><span class="comment"># rearrange the order of columns</span></div><div class="line">DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>])</div></pre></td></tr></table></figure></p>
<p>As with Series, if you pass a column that isn’t contained in data, it will appear with NA values in the result:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (continued)</span></div><div class="line">frame2 = DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>], index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</div><div class="line">frame2</div><div class="line">frame2.columns</div><div class="line"><span class="comment"># A column in a DataFrame can be retrieved as a Series</span></div><div class="line"><span class="comment">## Mehtod 1. by dict-lik notation</span></div><div class="line">frame2[<span class="string">'state'</span>]</div><div class="line"><span class="comment"># Method 2. by attribute</span></div><div class="line">frame2.year</div><div class="line">frame2.loc[<span class="string">'three'</span>]</div></pre></td></tr></table></figure></p>
<p>Columns can be modified by assignment:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></div><div class="line">frame2</div><div class="line">frame2[<span class="string">'debt'</span>] = np.arange(<span class="number">5.</span>)</div><div class="line">frame2</div></pre></td></tr></table></figure></p>
<p>If you assign a Series to a column, it will be instead conformed exactly to the DataFrame’s index, inserting missing values in any holes:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (continued)</span></div><div class="line">val = Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index=[<span class="string">'two'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>]) <span class="comment"># a series</span></div><div class="line">frame2[<span class="string">'debt'</span>] = val</div><div class="line">frame2</div></pre></td></tr></table></figure></p>
<p>Add or delete a column from a DataFrame:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame2[<span class="string">'eastern'</span>] = frame2.state == <span class="string">'Ohio'</span></div><div class="line">frame2</div><div class="line"><span class="keyword">del</span> frame2[<span class="string">'eastern'</span>]</div><div class="line">frame2.columns</div></pre></td></tr></table></figure></p>
<p>Note the column returned when indexing a DataFrame is a view on the underlying data, not a copy. Thus, any in-place modifications to the Series will be reflected in the DataFrame. The column can be explicitly copied using the Series’s copy method.</p>
<p>When a <code>nested dict</code> is passed to DataFrame, it will interpret the <code>outer</code> dict keys of the passed data as the <code>columns</code> and the inner keys as the row indices. The keys in the inner dicts are unioned and sorted to form the index in the result. This rule isn’t true if an explicit index is specified:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;, <span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</div><div class="line">frame3 = DataFrame(pop)</div><div class="line">frame3</div><div class="line">frame3.T</div><div class="line"><span class="comment"># If an explicit index is specified, it follows your specified list of index.</span></div><div class="line">DataFrame(pop, index=[<span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>])</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;, <span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</div><div class="line">frame3 = DataFrame(pop)</div><div class="line">frame3</div><div class="line">pdata = &#123;<span class="string">'Ohio'</span>: frame3[<span class="string">'Ohio'</span>][:<span class="number">-1</span>], <span class="string">'Nevada'</span>: frame3[<span class="string">'Nevada'</span>][:<span class="number">2</span>]&#125;</div><div class="line">DataFrame(pdata)</div></pre></td></tr></table></figure>
<p>If a DataFrame’s index and columns have their name attributes set, these will also be displayed:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (continued)</span></div><div class="line">frame3.index.name = <span class="string">'year'</span>; frame3.columns.name = <span class="string">'state'</span></div><div class="line">frame3</div><div class="line">frame3.values</div><div class="line">frame2</div><div class="line">frame2.values</div></pre></td></tr></table></figure></p>
<h4 id="Index-objects"><a href="#Index-objects" class="headerlink" title="Index objects"></a>Index objects</h4><p>Any array or other sequence of labels used when constructing a Series or DataFrame is internally converted to an Index. In addition to being array-like, an Index also functions as a fixed-size set:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">obj = Series(range(<span class="number">3</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">index = obj.index</div><div class="line">index</div><div class="line">obj = Series(np.arange(<span class="number">3</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">index = obj.index</div><div class="line">index</div><div class="line">index[<span class="number">1</span>:]</div><div class="line">index[<span class="number">1</span>] = <span class="string">'d'</span> <span class="comment"># Error!! Index objects are immutable</span></div><div class="line">index = pd.Index(np.arange(<span class="number">3</span>))</div><div class="line">obj2 = Series([<span class="number">1.5</span>, <span class="number">-2.5</span>, <span class="number">0</span>], index=index)</div><div class="line">obj2.index <span class="keyword">is</span> index</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;, <span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</div><div class="line">frame3 = DataFrame(pop)</div><div class="line">frame3</div><div class="line"><span class="string">'Ohio'</span> <span class="keyword">in</span> frame3.columns</div><div class="line"><span class="number">2003</span> <span class="keyword">in</span> frame3.index</div></pre></td></tr></table></figure>
<p>Index methods: append, diff, intersection, union, isin, delete, drop, insert, is_monotonic, is_unique, unique</p>
<h4 id="Reindexing"><a href="#Reindexing" class="headerlink" title="Reindexing"></a>Reindexing</h4><p>To create a new object with the data conformed to a new index:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">obj = Series([<span class="number">4.5</span>, <span class="number">7.2</span>, <span class="number">-5.3</span>, <span class="number">3.6</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</div><div class="line">obj</div><div class="line">obj2 = obj.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line">obj2</div><div class="line">obj.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>], fill_value=<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>For ordered data like time series, it may be desirable to do some interpolation or filling of values when reindexing. The method option allows us to do this, using a method such as ffill which <code>forward fills</code> the values:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">obj3 = Series([<span class="string">'blue'</span>, <span class="string">'purple'</span>, <span class="string">'yellow'</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</div><div class="line">obj3.reindex(range(<span class="number">6</span>), method=<span class="string">'ffill'</span>)</div><div class="line">frame = DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], columns=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'California'</span>])</div><div class="line">frame</div><div class="line">frame2 = frame.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</div><div class="line">frame2</div><div class="line">states = [<span class="string">'Texas'</span>, <span class="string">'Utah'</span>, <span class="string">'California'</span>]</div><div class="line">frame.reindex(columns=states)</div><div class="line">frame.loc[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], states]</div><div class="line">frame.reindex(index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], method=<span class="string">'ffill'</span>, columns=states) <span class="comment"># Doesn't work</span></div></pre></td></tr></table></figure></p>
<p>more: index, method, fill_value, limit, level, copy<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Dropping entries from an axis</span></div><div class="line">obj = Series(np.arange(<span class="number">5.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line">new_obj = obj.drop(<span class="string">'c'</span>)</div><div class="line">new_obj</div><div class="line">obj.drop([<span class="string">'d'</span>, <span class="string">'c'</span>])</div><div class="line">data = DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</div><div class="line">data.drop([<span class="string">'Colorado'</span>, <span class="string">'Ohio'</span>])</div><div class="line">data.drop(<span class="string">'two'</span>, axis=<span class="number">1</span>) <span class="comment"># delete it from columns</span></div><div class="line">data.drop([<span class="string">'two'</span>, <span class="string">'four'</span>], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>Series indexing (obj[…]) works analogously to NumPy array indexing, except you can use the Series’s index values instead of only integers.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Indexing, selection, and filtering</span></div><div class="line">obj = Series(np.arange(<span class="number">4.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</div><div class="line">obj</div><div class="line">obj[<span class="string">'b'</span>]</div><div class="line">obj[<span class="number">1</span>]</div><div class="line">obj[<span class="number">2</span>:<span class="number">4</span>]</div><div class="line">obj[[<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]]</div><div class="line">obj[[<span class="number">1</span>, <span class="number">3</span>]]</div><div class="line">obj[obj &lt; <span class="number">2</span>]</div><div class="line">obj[<span class="string">'b'</span>:<span class="string">'c'</span>]</div><div class="line">obj[<span class="string">'b'</span>:<span class="string">'c'</span>] = <span class="number">5</span></div><div class="line">obj</div></pre></td></tr></table></figure></p>
<p>As you’ve seen above, indexing into a DataFrame is for retrieving one or more columns either with a single value or sequence. Indexing like this has a few special cases. First selecting rows by slicing or a boolean array:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">data = DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</div><div class="line">data</div><div class="line">data[<span class="string">'two'</span>]</div><div class="line">data[[<span class="string">'three'</span>, <span class="string">'one'</span>]]</div><div class="line">data[:<span class="number">2</span>]</div><div class="line">data[data[<span class="string">'three'</span>] &gt; <span class="number">5</span>]</div><div class="line"><span class="comment">#  Another use case is in indexing with a boolean DataFrame, such as one produced by a scalar comparison:</span></div><div class="line">data &lt; <span class="number">5</span></div><div class="line">data[data &lt; <span class="number">5</span>] = <span class="number">0</span></div><div class="line">data</div><div class="line">data.loc[<span class="string">'Colorado'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]]</div><div class="line">data.iloc[<span class="number">2</span>,:]</div><div class="line">data.loc[:<span class="string">'Utah'</span>, <span class="string">'two'</span>]</div><div class="line"><span class="comment"># to replicate the result from data.ix(data.three&gt;5,:3)</span></div><div class="line">data.index[data.three &gt; <span class="number">5</span>].tolist()</div><div class="line">data.index[data.three &gt; <span class="number">5</span>]</div><div class="line">data.loc[data.index[data.three &gt; <span class="number">5</span>].tolist(), data.columns[:<span class="number">3</span>]] <span class="comment"># tricky.!! Method 1</span></div><div class="line">dx1 = list(np.where(data.three&gt;<span class="number">5</span>)[<span class="number">0</span>]) <span class="comment"># The tricky thing is we need [0].!!!!!!! Otherwise, it doesn't work.</span></div><div class="line">data.iloc[dx1,[<span class="number">1</span>,<span class="number">2</span>]] <span class="comment"># tricky.!! Method 2.</span></div><div class="line">data.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">## reindex method, xs method, icol, irow methods, get_value and set_value method</span></div><div class="line"><span class="comment"># Arithmetic, data alignment, value filling</span></div><div class="line"></div><div class="line">s1 = Series([<span class="number">7.3</span>, <span class="number">-2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line">s2 = Series([<span class="number">-2.1</span>, <span class="number">3.6</span>, <span class="number">-1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>], index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>])</div><div class="line">s1</div><div class="line">s2</div><div class="line"><span class="comment"># The internal data alignment introduces NA values in the indices that don’t overlap.</span></div><div class="line">s1 + s2</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">df1 = DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=list(<span class="string">'bcd'</span>), index=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Colorado'</span>])</div><div class="line">df2 = DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=list(<span class="string">'bde'</span>), index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</div><div class="line">df1</div><div class="line">df2</div><div class="line">df1 + df2</div><div class="line"><span class="comment"># Arithmetic methods with fill values</span></div><div class="line">df1 = DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)), columns=list(<span class="string">'abcd'</span>))</div><div class="line">df2 = DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)), columns=list(<span class="string">'abcde'</span>))</div><div class="line">df1</div><div class="line">df2</div><div class="line"><span class="comment"># Adding these together results in NA values in the locations that don’t overlap:</span></div><div class="line">df1 + df2</div><div class="line"><span class="comment"># Using the add method on df1, I pass df2 and an argument to fill_value:</span></div><div class="line">df1.add(df2, fill_value=<span class="number">0</span>)</div><div class="line">df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>more: add, sub, div, mul<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Operations between DataFrame and Series</span></div><div class="line">arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line">arr</div><div class="line">arr[<span class="number">0</span>]</div><div class="line">arr - arr[<span class="number">0</span>]</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">frame = DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=list(<span class="string">'bde'</span>), index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>]) series = frame.ix[<span class="number">0</span>]</div><div class="line">frame</div><div class="line">series</div><div class="line"><span class="comment"># By default, arithmetic between DataFrame and Series matches the index of the Series on the DataFrame's columns, broadcasting down the rows:</span></div><div class="line">frame - series</div><div class="line">series2 = Series(range(<span class="number">3</span>), index=[<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</div><div class="line"><span class="comment"># If an index value is not found in either the DataFrame’s columns or the Series’s index, the objects will be reindexed to form the union:</span></div><div class="line">frame + series2</div><div class="line"><span class="comment"># If you want to instead broadcast over the columns, "matching on the rows", you have to use one of the arithmetic methods.</span></div><div class="line">series3 = frame[<span class="string">'d'</span>]</div><div class="line">frame</div><div class="line">series3</div><div class="line">frame.sub(series3, axis=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>NumPy ufuncs (element-wise array methods) work fine with pandas objects:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Function application and mapping</span></div><div class="line">frame = DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>), index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</div><div class="line">frame</div><div class="line">np.abs(frame)</div><div class="line">f = <span class="keyword">lambda</span> x: x.max() - x.min()</div><div class="line"><span class="comment"># apply a function on 1D arrays to each row</span></div><div class="line">frame.apply(f) <span class="comment"># Over rows, degenerate to a column vector</span></div><div class="line">frame.apply(f, axis=<span class="number">1</span>) <span class="comment"># Over columns, degenerate to a row vector</span></div><div class="line"></div><div class="line"><span class="comment"># The function passed to apply need not return a scalar value, it can also return a Series with multiple values:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</div><div class="line">frame.apply(f)</div><div class="line"></div><div class="line"><span class="comment"># "Element-wise" Python functions can be used, too. Suppose you wanted to compute a formatted string from each floating point value in frame. You can do this with applymap:</span></div><div class="line">format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x</div><div class="line">frame.applymap(format)</div><div class="line"><span class="comment"># The reason for the name applymap is that Series has a map method for applying an element-wise function:</span></div><div class="line">frame[<span class="string">'e'</span>].map(format)</div></pre></td></tr></table></figure></p>
<p>Sorting a data set by some criterion is another important built-in operation. To sort lexicographically by row or column index, use the sort_index method, which returns a new, sorted object:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sorting and ranking, p.133</span></div><div class="line"><span class="comment"># to sort lexicographically by row or column index, use the sort_index method,</span></div><div class="line">obj = Series(range(<span class="number">4</span>), index=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">obj.sort_index()</div><div class="line">frame = DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)), index=[<span class="string">'three'</span>, <span class="string">'one'</span>], columns=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">frame.sort_index()</div><div class="line">frame.sort_index(axis=<span class="number">1</span>)</div><div class="line">frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>)</div><div class="line"><span class="comment"># to sort a series its values, use its order method,</span></div><div class="line">obj = Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>])</div><div class="line">obj.order()</div><div class="line">obj = Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, <span class="number">-3</span>, <span class="number">2</span>])</div><div class="line"><span class="comment"># any missing values are sorted to the end of the Series by default</span></div><div class="line">obj.order()</div><div class="line"><span class="comment"># to sort by the values in one or more columns on DataFrame, pass one or more colums to the `by` option:</span></div><div class="line">frame = DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</div><div class="line">frame</div><div class="line">frame.sort_index(by=<span class="string">'b'</span>)</div><div class="line">frame.sort_index(by=[<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"><span class="comment"># ranking is assigning ranks from one through the number of valid data points in an array. By default, `rank` breaks ties by assigning each group the mean rank.</span></div><div class="line">obj = Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</div><div class="line">obj.rank()</div><div class="line">obj.rank(method=<span class="string">'first'</span>)</div><div class="line"><span class="comment"># you can rank in descending order</span></div><div class="line">obj.rank(ascending=<span class="keyword">False</span>, method=<span class="string">'max'</span>)</div><div class="line"><span class="comment"># DataFrame can compute ranks over the rows or the columns:</span></div><div class="line">frame = DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4.3</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="string">'c'</span>: [<span class="number">-2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">-2.5</span>]&#125;)</div><div class="line">frame</div><div class="line">frame.rank(axis=<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Axis indexes with duplicate values</span></div><div class="line">obj = Series(range(<span class="number">5</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">obj</div><div class="line"><span class="comment"># the index's is_unique property can tell you whether its values are unique:</span></div><div class="line">obj.index.is_unique</div><div class="line">obj[<span class="string">'a'</span>]</div><div class="line">obj[<span class="string">'c'</span>]</div><div class="line">df = DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>])</div><div class="line">df</div><div class="line">df.ix[<span class="string">'b'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Summarizing and computing descriptive statistics</span></div><div class="line">df = DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, <span class="number">-4.5</span>], [np.nan, np.nan], [<span class="number">0.75</span>, <span class="number">-1.3</span>]], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>])</div><div class="line">df</div><div class="line"><span class="comment"># NA values are excluded unless the entire slice (row or column in this case) is NA. This can be disabled using the skipna option.</span></div><div class="line">df.sum()</div><div class="line">df.sum(axis=<span class="number">1</span>) <span class="comment"># axis represents the axis to reduce over.</span></div><div class="line">df.mean(axis=<span class="number">1</span>, skipna=<span class="keyword">False</span>)</div><div class="line"><span class="comment"># return indirect statistics like the index value where the max or min values are attained:</span></div><div class="line">df.idxmax()</div><div class="line">df.cumsum()</div><div class="line">df.describe()</div><div class="line">obj = Series([<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] * <span class="number">4</span>)</div><div class="line">obj.describe()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Correlation and covariance</span></div><div class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> web</div><div class="line">all_data = &#123;&#125;</div><div class="line"><span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">'AAPL'</span>, <span class="string">'IBM'</span>, <span class="string">'MSFT'</span>, <span class="string">'GOOG'</span>]: all_data[ticker] = web.get_data_yahoo(ticker)</div><div class="line">price = DataFrame(&#123;tic: data[<span class="string">'Adj Close'</span>] <span class="keyword">for</span> tic, data <span class="keyword">in</span> all_data.iteritems()&#125;)</div><div class="line">volume = DataFrame(&#123;tic: data[<span class="string">'Volume'</span>] <span class="keyword">for</span> tic, data <span class="keyword">in</span> all_data.iteritems()&#125;)</div><div class="line">returns = price.pct_change()</div><div class="line">returns.tail()</div><div class="line"><span class="comment"># correlation of the overlapping, non-NA, aligned-by-index calues in two Series</span></div><div class="line">returns.MSFT.corr(returns.IBM)</div><div class="line">returns.MSFT.cov(returns.IBM)</div><div class="line">returns.corr()</div><div class="line">returns.cov()</div><div class="line"><span class="comment"># compute pairwise correlation between a DataFrame's columns or rows with anther Series or DataFrame</span></div><div class="line">returns.corrwith(returns.IBM)</div><div class="line">returns.corrwith(volume)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Unique values, value counts, and membership</span></div><div class="line">obj = Series([<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>])</div><div class="line">uniques = obj.unique() <span class="comment"># gives an array of the unique values in a Series</span></div><div class="line">uniques</div><div class="line">uniques.sort()</div><div class="line">uniques</div><div class="line">obj.value_counts()</div><div class="line"><span class="comment"># The Series is sorted by value in descending order as a convenience. value_counts is also available as a top-level pandas method that can be used with any array or sequence:</span></div><div class="line">pd.value_counts(obj.values, sort=<span class="keyword">False</span>)</div><div class="line">mask = obj.isin([<span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">mask</div><div class="line">obj[mask] <span class="comment"># select out those data with rows of interest</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data = DataFrame(&#123;<span class="string">'Qu1'</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'Qu2'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'Qu3'</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</div><div class="line">data</div><div class="line">result = data.apply(pd.value_counts).fillna(<span class="number">0</span>) <span class="comment"># trick</span></div><div class="line">result</div></pre></td></tr></table></figure>
<p>pandas uses the floating point value NaN (Not a Number) to represent missing data in both floating as well as in non-floating point arrays. It is just used as a sentinel that can be easily detected:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Handling missing data</span></div><div class="line">string_data = Series([<span class="string">'aardvark'</span>, <span class="string">'artichoke'</span>, np.nan, <span class="string">'avocado'</span>])</div><div class="line">string_data</div><div class="line">string_data.isnull()</div><div class="line"><span class="comment"># The built-in Python None value is also treated as NA in object arrays:</span></div><div class="line">string_data[<span class="number">0</span>] = <span class="keyword">None</span></div><div class="line">string_data.isnull()</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Filtering out missing data</span></div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</div><div class="line">data = Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</div><div class="line">data.dropna()</div><div class="line">data[data.notnull()]</div><div class="line"><span class="comment">#  You may want to drop rows or columns which are all NA or just those containing any NAs. dropna by default drops any row containing a missing value:</span></div><div class="line">data = DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA], [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</div><div class="line">cleaned = data.dropna()</div><div class="line">data</div><div class="line">cleaned</div><div class="line"><span class="comment"># Passing how='all' will only drop rows that are all NA:</span></div><div class="line">data.dropna(how=<span class="string">'all'</span>)</div><div class="line"><span class="comment"># Dropping columns in the same way is only a matter of passing axis=1:</span></div><div class="line">data[<span class="number">4</span>] = NA</div><div class="line">data</div><div class="line">data.dropna(axis=<span class="number">1</span>, how=<span class="string">'all'</span>)</div></pre></td></tr></table></figure>
<p>Suppose you want to keep only rows containing a certain number of observations. You can indicate this with the thresh argument:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">df = DataFrame(np.random.randn(<span class="number">7</span>, <span class="number">3</span>))</div><div class="line">df.ix[:<span class="number">4</span>, <span class="number">1</span>] = NA; df.ix[:<span class="number">2</span>, <span class="number">2</span>] = NA</div><div class="line">df</div><div class="line">df.dropna(thresh=<span class="number">3</span>) <span class="comment"># contains at least 3 valid values in a row</span></div><div class="line"><span class="comment"># Filling in missing data</span></div><div class="line">df.fillna(<span class="number">0</span>)</div><div class="line"><span class="comment"># Calling fillna with a dict you can use a different fill value for each column:</span></div><div class="line">df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">3</span>: <span class="number">-1</span>&#125;)</div><div class="line"><span class="comment"># fillna returns a new object, but you can modify the existing object in place:</span></div><div class="line"><span class="comment"># fillna always returns a reference to the filled object</span></div><div class="line">_ = df.fillna(<span class="number">0</span>, inplace=<span class="keyword">True</span>)</div><div class="line">df</div><div class="line">df = DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">3</span>)) df.ix[<span class="number">2</span>:, <span class="number">1</span>] = NA; df.ix[<span class="number">4</span>:, <span class="number">2</span>] = NA</div><div class="line">df</div><div class="line">df.fillna(method=<span class="string">'ffill'</span>)</div><div class="line">df.fillna(method=<span class="string">'ffill'</span>, limit=<span class="number">2</span>)</div><div class="line"><span class="comment"># With fillna you can do lots of other things with a little creativity. For example, you might pass the mean or median value of a Series:</span></div><div class="line">data = Series([<span class="number">1.</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</div><div class="line">data.fillna(data.mean())</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Hierarchical indexing</span></div><div class="line">data = Series(np.random.randn(<span class="number">10</span>), index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</div><div class="line">data</div><div class="line">data.index</div><div class="line"><span class="comment"># With a hierarchically-indexed object, so-called partial indexing is possible, enabling you to concisely select subsets of the data:</span></div><div class="line">data[<span class="string">'b'</span>]</div><div class="line"><span class="comment"># method 1:</span></div><div class="line">data[<span class="string">'b'</span>:<span class="string">'c'</span>]</div><div class="line"><span class="comment"># method 2:</span></div><div class="line">data.ix[[<span class="string">'b'</span>, <span class="string">'d'</span>]]</div><div class="line"><span class="comment"># Selection is even possible in some cases from an “inner” level:</span></div><div class="line">data[:, <span class="number">2</span>]</div><div class="line">data.unstack()</div><div class="line">data.unstack().stack()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">frame = DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]], columns=[[<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>], [<span class="string">'Green'</span>, <span class="string">'Red'</span>, <span class="string">'Green'</span>]])</div><div class="line">frame</div><div class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>] frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</div><div class="line">frame</div><div class="line">frame[<span class="string">'Ohio'</span>]</div><div class="line">MultiIndex.from_arrays([[<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>], [<span class="string">'Green'</span>, <span class="string">'Red'</span>, <span class="string">'Green'</span>]], names=[<span class="string">'state'</span>, <span class="string">'color'</span>])</div><div class="line"></div><div class="line"><span class="comment"># Reordering and sorting levels</span></div><div class="line"><span class="comment">#  The swaplevel takes two level numbers or names and returns a new object with the levels interchanged (but the data is otherwise unaltered):</span></div><div class="line">frame.swaplevel(<span class="string">'key1'</span>, <span class="string">'key2'</span>)</div><div class="line">frame.sortlevel(<span class="number">1</span>)</div><div class="line">frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sortlevel(<span class="number">0</span>) <span class="comment"># the same result as the command above</span></div><div class="line"></div><div class="line"><span class="comment"># Summary statistics by level</span></div><div class="line">frame.sum(level=<span class="string">'key2'</span>)</div><div class="line">frame.sum(level=<span class="string">'color'</span>, axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>It’s not unusual to want to use one or more columns from a DataFrame as the row index; alternatively, you may wish to move the row index into the DataFrame’s columns.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Using a DataFrame's columns</span></div><div class="line">frame = DataFrame(&#123;<span class="string">'a'</span>: range(<span class="number">7</span>), <span class="string">'b'</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="string">'c'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>], <span class="string">'d'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</div><div class="line">frame</div><div class="line">frame2 = frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>])</div><div class="line">frame2</div><div class="line"><span class="comment"># By default the columns are removed from the DataFrame, though you can leave them in:</span></div><div class="line">frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>], drop=<span class="keyword">False</span>)</div><div class="line">frame2.reset_index()</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Other pandas topics</span></div><div class="line"><span class="comment"># Integer indexing</span></div><div class="line">ser = Series(np.arange(<span class="number">3.</span>))</div><div class="line">ser.iloc[<span class="number">-1</span>]</div><div class="line">ser</div><div class="line">ser2 = Series(np.arange(<span class="number">3.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">ser2[<span class="number">-1</span>]</div><div class="line">ser.ix[:<span class="number">1</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ser3 = Series(range(<span class="number">3</span>), index=[<span class="number">-5</span>, <span class="number">1</span>, <span class="number">3</span>])</div><div class="line">ser3.iloc[<span class="number">2</span>]</div><div class="line"></div><div class="line">frame = DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">3</span>, <span class="number">2</span>)), index=[<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</div><div class="line">frame.iloc[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>To create a Panel, you can use a dict of DataFrame objects or a three-dimensional ndarray:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Panel data</span></div><div class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> web</div><div class="line">pdata = pd.Panel(dict((stk, web.get_data_yahoo(stk)) <span class="keyword">for</span> stk <span class="keyword">in</span> [<span class="string">'AAPL'</span>, <span class="string">'GOOG'</span>, <span class="string">'MSFT'</span>, <span class="string">'DELL'</span>]))</div><div class="line">pdata</div><div class="line">pdata = pdata.swapaxes(<span class="string">'items'</span>, <span class="string">'minor'</span>)</div><div class="line">pdata[<span class="string">'Adj Close'</span>]</div><div class="line"><span class="comment"># ix-based label indexing generalizes to three dimensions, so we can select all data at a particular date or a range of dates like so</span></div><div class="line">pdata.ix[:, <span class="string">'6/1/2012'</span>, :]</div><div class="line">pdata.ix[<span class="string">'Adj Close'</span>, <span class="string">'5/22/2012'</span>:, :]</div><div class="line"><span class="comment"># An alternate way to represent panel data, especially for fitting statistical models, is in “stacked” DataFrame form:</span></div><div class="line">stacked = pdata.ix[:, <span class="string">'5/30/2012'</span>:, :].to_frame()</div><div class="line">stacked</div><div class="line"><span class="comment"># DataFrame has a related to_panel method, the inverse of to_frame:</span></div><div class="line">stacked.to_panel()</div></pre></td></tr></table></figure></p>
<h2 id="Python-OOP"><a href="#Python-OOP" class="headerlink" title="Python OOP"></a>Python OOP</h2><p>OOP refers to Object-Oriented Programming.</p>
<h2 id="Applications-of-Python"><a href="#Applications-of-Python" class="headerlink" title="Applications of Python"></a>Applications of Python</h2><h3 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h3><p>statistical model, machien learning algorithm<br>adfadsf</p>
<h3 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h3><p>adfadsf</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>fadsf</p>
<h3 id="Tableau"><a href="#Tableau" class="headerlink" title="Tableau"></a>Tableau</h3><p>Reference: <a href="https://community.tableau.com/thread/236479" target="_blank" rel="external">Tableau Integration with Python</a></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Data munging or data wrangling is loosely the process of manually converting or mapping data from one “raw” form into another format that allows for more convenient consumption of the data with the help of semi-automated tools.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Set symmetric differences: elements that are in either of the arrays, but not both.</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/note/2017/09/08/english-sentence/" rel="next" title="english_sentence">
                <i class="fa fa-chevron-left"></i> english_sentence
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">n0body</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/note/archives">
            
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python"><span class="nav-text">Python</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Interaction-with-OS-and-Jupyter"><span class="nav-text">Interaction with OS and Jupyter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Find-and-change-current-directory-general"><span class="nav-text">Find and change current directory [general]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Clear-all-variables-in-variable-explorer-Spyder"><span class="nav-text">Clear all variables in variable explorer [Spyder]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tab-completion-and-introspection-Jupyter"><span class="nav-text">Tab completion and introspection [Jupyter]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Execute-code-from-the-clipboard-Jupyter"><span class="nav-text">Execute code from the clipboard [Jupyter]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Interacting-with-the-operating-system-Jupyter"><span class="nav-text">Interacting with the operating system [Jupyter]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timing-the-runtime-of-your-code-general"><span class="nav-text">Timing the runtime of your code [general]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NumPy"><span class="nav-text">NumPy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ndarray"><span class="nav-text">ndarray</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Random-ndarray"><span class="nav-text">Random ndarray</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Create-ndarrays-array-zeros-empty-arange"><span class="nav-text">Create ndarrays: array(), zeros(), empty(), arange()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Data-type-conversion-astype-float64-f8-int32-i4-np-string-np-unicode"><span class="nav-text">Data type conversion: astype(), float64(=f8), int32(=i4), np.string, np.unicode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Transposing-arrays-and-swapping-axes-transpose-dot-swapaxes"><span class="nav-text">Transposing arrays and swapping axes: transpose, dot, swapaxes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Universal-functions"><span class="nav-text">Universal functions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Unary-universal-functions"><span class="nav-text">Unary universal functions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Binary-universal-functions"><span class="nav-text">Binary universal functions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Indexing-and-slicing"><span class="nav-text">Indexing and slicing</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Basics"><span class="nav-text">Basics</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Indexing-with-slices"><span class="nav-text">Indexing with slices</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Boolean-indexing"><span class="nav-text">Boolean indexing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Fancy-indexing-ix"><span class="nav-text">Fancy indexing: ix_()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Application-of-meshgrid-method"><span class="nav-text">Application of meshgrid method</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Conditional-logic-on-array-operations-zip-all-where"><span class="nav-text">Conditional logic on array operations: zip, all, where</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Application-of-boolean-array-counting-events"><span class="nav-text">Application of boolean array: counting events</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set-logic-unique"><span class="nav-text">Set logic: unique()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-and-stat-methods"><span class="nav-text">Math and stat methods</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#application-of-sorting-quantiles"><span class="nav-text">application of sorting: quantiles</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-input-and-output"><span class="nav-text">File input and output</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#np-save-np-load-np-savez"><span class="nav-text">np.save, np.load, np.savez</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#np-loadtxt"><span class="nav-text">np.loadtxt</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linear-algebra"><span class="nav-text">Linear algebra</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Random-number-generation"><span class="nav-text">Random number generation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#faster-randomization"><span class="nav-text">faster randomization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#first-crossing-times"><span class="nav-text">first crossing times</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pandas"><span class="nav-text">Pandas</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Modules"><span class="nav-text">Modules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Series"><span class="nav-text">Series</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataFrame"><span class="nav-text">DataFrame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Index-objects"><span class="nav-text">Index objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reindexing"><span class="nav-text">Reindexing</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-OOP"><span class="nav-text">Python OOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applications-of-Python"><span class="nav-text">Applications of Python</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Machine-Learning"><span class="nav-text">Machine Learning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deep-Learning"><span class="nav-text">Deep Learning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-text">MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tableau"><span class="nav-text">Tableau</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">n0body</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/note/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/note/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/note/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/note/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/note/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/note/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/note/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/note/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/note/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/note/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/note/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/note/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/note/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/note/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/note/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
